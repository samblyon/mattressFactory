{"version":3,"sources":["webpack:///webpack/bootstrap 1ac68551632f07283210","webpack:///./js/main.js","webpack:///./js/game.js","webpack:///./js/game_view.js","webpack:///./js/map.js","webpack:///./js/coord.js","webpack:///./js/ray.js","webpack:///./js/util.js","webpack:///./js/wall.js","webpack:///./js/player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;AChBD;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA0B,kBAAkB,EAAE;AAC9C,MAAK;;AAEL,+BAA8B,oBAAoB;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/BA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA,gCAA+B;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1ac68551632f07283210\n **/","const Game = require('./game.js');\nconst GameView = require('./game_view.js');\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n  console.log(\"Hey there\");\n  const canvas = document.getElementById('canvas');\n  canvas.width = 400;\n  canvas.height = 400;\n\n  const ctx = canvas.getContext(\"2d\");\n  ctx.fillStyle = \"#222\";\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const map = new Map();\n  window.GameView = new GameView(canvas, map);\n  window.GameView.start();\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/main.js\n ** module id = 0\n ** module chunks = 0\n **/","class Game {\n  constructor(){\n    // this.grid =\n  }\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/game.js\n ** module id = 1\n ** module chunks = 0\n **/","const Map = require('./map');\n\nclass GameView {\n  constructor(canvas, map){\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\"2d\");\n    this.map = new Map(canvas);\n    this.player = this.map.player;\n    this.bindKeyHandlers();\n  }\n\n  bindKeyHandlers() {\n    const player = this.player;\n\n    Object.keys(GameView.MOVES).forEach((k) => {\n      let dir = GameView.MOVES[k];\n      key(k, function () { player.move(dir); });\n    });\n\n    key(\"space\", function () { player.emitRays() });\n  }\n\n  start(){\n    //bind key handlers\n\n    //start animation\n    requestAnimationFrame(this.step.bind(this));\n  }\n\n  step () {\n    this.ctx.fillStyle = \"#222\";\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.map.step();\n    this.map.draw(this.ctx);\n\n    //request another animation\n    requestAnimationFrame(this.step.bind(this));\n\n    // when game is over\n    // window.clearInterval(this.intervalId);\n  }\n\n};\n\nGameView.MOVES = {\n  \"up\": \"U\",\n  \"down\": \"D\",\n  \"left\": \"L\",\n  \"right\": \"R\"\n}\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/game_view.js\n ** module id = 2\n ** module chunks = 0\n **/","const Coord = require('./coord');\nconst Ray = require('./ray');\nconst Util = require('./util');\nconst Wall = require('./wall');\nconst Player = require('./player');\n\nclass Map {\n  constructor(canvas){\n    const pegCoord = new Coord(20, 20);\n    const dirCoord = new Coord(1, 2);\n    const testRay = new Ray(pegCoord, dirCoord, this);\n    window.rays = this.rays = [];\n    this.walls = Map.LEVELS[1].map(info => new Wall(...info));\n    window.player = this.player = new Player(20, 20, this);\n    this.canvas = canvas;\n  }\n\n  collidingWithWall(coord){\n    return this.walls.some( wall => {\n      return !(\n        (coord.x < wall.topLeft.x)\n          || (coord.x > wall.bottomRight.x)\n          || (coord.y < wall.topLeft.y)\n          || (coord.y > wall.bottomRight.y)\n      );\n    });\n  }\n\n  cullRays(){\n    this.rays = this.rays.filter(ray => {\n      return ray.age < Ray.LIFESPAN;\n    });\n  }\n\n  moveRays(){\n    for (let ray of this.rays) {\n      ray.move();\n    }\n  }\n\n  step(){\n    this.cullRays();\n    this.moveRays();\n  }\n\n  draw(ctx){\n    this.player.draw(ctx);\n    this.rays.forEach(ray => ray.draw(ctx));\n    this.walls.forEach(wall => wall.draw(ctx)); //remove this on release\n  }\n};\n\nMap.LEVELS = {\n  1: [\n      [1, 1, 10, 399],\n      [1, 1, 399, 10],\n      [390, 1, 399, 399],\n      [1, 390, 370, 399],\n      [50, 200, 200, 210],\n      [100, 100, 110, 200],\n      [200, 40, 210, 100],\n      [200, 60, 320, 70],\n      [260, 70, 270, 300]\n    ]\n}\n\nmodule.exports = Map;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/map.js\n ** module id = 3\n ** module chunks = 0\n **/","class Coord {\n  constructor(x, y){\n    this.x = x;\n    this.y = y;\n  }\n\n  equals(otherCoord){\n    return (this.x === otherCoord.x)\n      && (this.y === otherCoord.y)\n  }\n\n  getAdjacentCoords(){\n    return Coord.MOVES.map(move => {\n      const newX = this.x + move[0];\n      const newY = this.y + move[1];\n      return new Coord(newX, newY);\n    });\n  }\n}\n\nCoord.MOVES = [\n  [0, 1],\n  [0, -1],\n  [1, 0],\n  [-1, 0],\n  [1, 1],\n  [1, -1],\n  [-1, 1],\n  [-1, -1]\n];\n\nmodule.exports = Coord;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/coord.js\n ** module id = 4\n ** module chunks = 0\n **/","const Coord = require('./coord');\n\nclass Ray {\n  constructor(origin, direction, map, age, maxLength){\n    this.body = [origin];  //origin is coord object\n    this.head = origin;\n    this.tail = origin;\n    this.map = map;\n\n    this.direction = direction; //direction is coord object\n    this.speed = Ray.VELOCITY;\n\n    this.age = (age) ? age : 0;\n    this.maxLength = (maxLength) ? maxLength : Ray.MAX_LENGTH;\n    this.fading = false;\n  }\n\n  move(){\n    if (this.age < (Ray.LIFESPAN - 60)) {\n      if (this.handleCollisions() === false){\n        this.growHead();\n      }\n    }\n\n    if (this.body.length > this.maxLength){\n      this.fading = true;\n    }\n\n    if (this.fading) {\n      this.fadeTail()\n    }\n\n    this.age += 1;\n  }\n\n  // move head x and ask map if collided with wall\n  // move head y and ask map if collided with wall\n  // alter this.direction coord to reflect one or both bounces as needed\n  handleCollisions(){\n    const newX = this.head.x + (this.direction.x * this.speed);\n    const xExplorer = new Coord(newX, this.head.y);\n    const xCollision = this.map.collidingWithWall(xExplorer);\n\n    const newY = this.head.y + (this.direction.y * this.speed);\n    const yExplorer = new Coord(this.head.x, newY);\n    const yCollision = this.map.collidingWithWall(yExplorer);\n\n    const zExplorer = new Coord(newX, newY);\n    const zCollision = this.map.collidingWithWall(zExplorer);\n\n    if (xCollision || yCollision || zCollision) {\n      // generate reflected ray\n\n      // reflect direction based on collision\n      const reflectionDirection = new Coord(this.direction.x, this.direction.y);\n      if (xCollision) {\n        reflectionDirection.x = -reflectionDirection.x;\n      } else if (yCollision) {\n        reflectionDirection.y = -reflectionDirection.y;\n      } else {\n        reflectionDirection.y = -reflectionDirection.y;\n        reflectionDirection.x = -reflectionDirection.x;\n      }\n\n      const origin = new Coord(this.head.x, this.head.y);\n      const reflection = new Ray(\n        origin,\n        reflectionDirection,\n        this.map,\n        this.age,        // advance new ray age to parent ray current age\n        this.body.length // set new ray max length\n      );\n\n      this.map.rays.push(reflection);\n      console.log(this.map.rays.length);\n\n      // stop expansion of current ray\n      this.direction.x = 0;\n      this.direction.y = 0;\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  growHead(){\n    const newX = this.head.x + (this.direction.x * this.speed);\n    const newY = this.head.y + (this.direction.y * this.speed);\n    this.head = new Coord(newX, newY);\n    this.body.push(this.head); // collision logic could be added before this push\n  }\n\n  fadeTail(){\n    let i = 0;\n    while (i < Ray.VELOCITY) {\n      this.body.shift();\n      i += 1;\n    }\n    this.tail = this.body[0];\n  }\n\n  bounce(){\n\n    // this.direction x or y should invert depending on nature of collision\n  }\n\n  draw(ctx){\n    if (this.body.length === 0) return;\n\n    ctx.lineWidth = Ray.THICKNESS;\n\n    // linear gradient from start to end of line\n    const grad = ctx.createLinearGradient(\n      this.head.x, this.head.y,\n      this.tail.x, this.tail.y\n    );\n    grad.addColorStop(0, Ray.HEAD_COLOR);\n    grad.addColorStop(1, Ray.TAIL_COLOR);\n\n    ctx.strokeStyle = grad;\n\n    ctx.beginPath();\n    ctx.moveTo(this.head.x, this.head.y);\n    ctx.lineTo(this.tail.x, this.tail.y);\n\n    ctx.stroke();\n  }\n};\n\nRay.MAX_LENGTH = 40;\nRay.HEAD_COLOR = \"#fff\";\nRay.TAIL_COLOR = \"#222\";\nRay.VELOCITY = 1;\nRay.LIFESPAN = 200;\nRay.THICKNESS = 1;\n\nconst rtTwo = Math.sqrt(2)/2;\nRay.DIRECTIONS = [\n  [0, rtTwo],\n  [0, -rtTwo],\n  [-rtTwo, 0],\n  [rtTwo, 0],\n  [rtTwo, rtTwo],\n  [rtTwo, -rtTwo],\n  [-rtTwo, rtTwo],\n  [-rtTwo, -rtTwo]\n];\n\n\nmodule.exports = Ray;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/ray.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = {\n  inherits(Child, Parent) {\n    function Surrogate (){};\n    Surrogate.prototype = Parent.prototype;\n    Child.prototype = new Surrogate();\n    Child.prototype.constructor = Child;\n  },\n\n  // inBounds(coord) {\n  //   return (coord.y >= 0) && (coord.y < this.grid.length)\n  //   && (coord.x >= 0) && (coord.x < this.grid[0].length);\n  // }\n\n  // isWall(coord) {\n  //   return (this.grid[coord.y][coord.x] === \"X\");\n  // }\n\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/util.js\n ** module id = 6\n ** module chunks = 0\n **/","const Coord = require('./coord');\n\nclass Wall {\n  constructor(topX, topY, bottomX, bottomY){\n    this.topLeft = new Coord(topX, topY);\n    this.bottomRight = new Coord(bottomX, bottomY);\n    this.width = bottomX - topX;\n    this.height = bottomY - topY;\n  }\n\n  draw(ctx){\n    ctx.fillStyle = \"#222\";\n    ctx.fillRect(this.topLeft.x, this.topLeft.y, this.width, this.height);\n  }\n}\n\nmodule.exports = Wall;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/wall.js\n ** module id = 7\n ** module chunks = 0\n **/","const Coord = require('./coord');\nconst Ray = require('./ray');\n\nclass Player {\n  constructor(startX, startY, map){\n    this.pos = new Coord(startX, startY);\n    this.map = map;\n  }\n\n  move(direction){\n    const newX = this.pos.x + (Player.MOVES[direction][0] * Player.SPEED)\n    const newY = this.pos.y + (Player.MOVES[direction][1] * Player.SPEED)\n    const exploreCoord = new Coord(newX, newY);\n\n    if (this.map.collidingWithWall(exploreCoord)) return;\n    this.pos = exploreCoord;\n    this.emitRays();\n  }\n\n  emitRays(){\n    const newRays = Ray.DIRECTIONS.map(dir => {\n      let dirVector = new Coord(dir[0], dir[1]);\n      return new Ray(this.pos, dirVector, this.map);\n    });\n    newRays.forEach( ray => {\n      this.map.rays.push(ray);\n    });\n  }\n\n  draw(ctx){\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(this.pos.x, this.pos.y, 4, 4);\n  }\n};\n\nPlayer.SPEED = 5;\nPlayer.MOVES = {\n  \"U\": [0, -1],\n  \"D\": [0, 1],\n  \"L\": [-1, 0],\n  \"R\": [1, 0]\n}\n\nmodule.exports = Player;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/player.js\n ** module id = 8\n ** module chunks = 0\n **/"],"sourceRoot":""}